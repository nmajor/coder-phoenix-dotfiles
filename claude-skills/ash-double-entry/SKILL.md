---
name: ash-double-entry
description: Double-entry accounting and financial ledgers. Use for accounting systems, bookkeeping, ledgers, financial transactions, debits, credits, balance tracking, and double-entry bookkeeping patterns.
---

# Ash-Double-Entry Skill

Comprehensive assistance with ash-double-entry development, generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Implementing double-entry accounting systems in Elixir/Ash
- Working with financial ledgers, accounts, or transactions
- Building applications that track debits, credits, and balances
- Implementing transfer systems between accounts
- Setting up accounting systems with Ash Framework
- Debugging ash-double-entry code or understanding its APIs
- Learning how to structure resources for double-entry bookkeeping
- Implementing financial record keeping with proper audit trails

## Key Concepts

### What is Double-Entry Accounting?

Double-entry accounting is a bookkeeping method where every transaction affects at least two accounts - one debit and one credit. The system ensures that debits always equal credits, maintaining balance integrity.

### Core Resources in Ash-Double-Entry

The library provides three main resource extensions:

1. **Account** - Represents ledger accounts (e.g., bank accounts, revenue, expenses)
2. **Transfer** - Represents transactions between accounts
3. **Balance** - Tracks account balances over time with ULID-based versioning

These extensions add the necessary attributes, relationships, actions, and validations to create a complete double-entry system.

### What Makes It Special?

- **Built on Ash Framework** - Leverages Ash's declarative approach for resource modeling
- **Automatic Balance Tracking** - Balances are automatically maintained via transfers
- **ULID-based Versioning** - Uses ULIDs for time-sortable balance snapshots
- **AshMoney Integration** - Proper money type support with currency handling
- **Atomic Operations** - Ensures data integrity through proper locking mechanisms

## Quick Reference

### 1. Basic Account Resource Setup

```elixir
defmodule YourApp.Ledger.Account do
  use Ash.Resource,
    domain: YourApp.Ledger,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshDoubleEntry.Account]

  postgres do
    table "accounts"
    repo YourApp.Repo
  end

  account do
    # Configure related resources
    transfer_resource YourApp.Ledger.Transfer
    balance_resource YourApp.Ledger.Balance
    # Accept custom attributes in the autogenerated `open` action
    open_action_accept [:account_number]
  end

  attributes do
    # Add custom attributes
    attribute :account_number, :string do
      allow_nil? false
    end
  end
end
```

*Defines a basic account resource with the AshDoubleEntry.Account extension, which provides the foundation for double-entry accounting.*

### 2. Transfer Resource Configuration

```elixir
defmodule YourApp.Ledger.Transfer do
  use Ash.Resource,
    domain: YourApp.Ledger,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshDoubleEntry.Transfer]

  postgres do
    table "transfers"
    repo YourApp.Repo
  end

  transfer do
    # Configure related resources
    account_resource YourApp.Ledger.Account
    balance_resource YourApp.Ledger.Balance

    # Only needed if not using postgres cascade deletion
    # destroy_balances? true
  end
end
```

*Creates a transfer resource that handles transactions between accounts. The extension automatically adds amount, from_account, to_account, and timestamp fields.*

### 3. Balance Resource with Cascade Deletion

```elixir
defmodule YourApp.Ledger.Balance do
  use Ash.Resource,
    domain: YourApp.Ledger,
    data_layer: AshPostgres.DataLayer,
    extensions: [AshDoubleEntry.Balance]

  postgres do
    table "balances"
    repo YourApp.Repo

    # Automatic cascade deletion when transfer is deleted
    references do
      reference :transfer, on_delete: :delete
    end
  end

  balance do
    # Configure related resources
    transfer_resource YourApp.Ledger.Transfer
    account_resource YourApp.Ledger.Account
  end

  actions do
    read :read do
      primary? true
      # Enable keyset pagination for streaming large balance histories
      pagination keyset?: true
    end
  end
end
```

*Balance resource with automatic cleanup and pagination support for efficient querying of balance history.*

### 4. Domain Configuration

```elixir
# In your config/config.exs
config :your_app,
  ash_domains: [..., YourApp.Ledger]
```

*Register your ledger domain with Ash for proper initialization.*

### 5. Handling Non-Atomic Updates

```elixir
# In your Transfer resource, if you have atomic? set to true globally
defmodule YourApp.Ledger.Transfer do
  use Ash.Resource,
    domain: YourApp.Ledger,
    extensions: [AshDoubleEntry.Transfer]

  transfer do
    account_resource YourApp.Ledger.Account
    balance_resource YourApp.Ledger.Balance
  end

  # Add this if config :ash, :default_actions_require_atomic? is true
  changes do
    change get_and_lock_for_update()
  end

  actions do
    update :update do
      require_atomic? false  # Safe because accounts are locked
    end
  end
end
```

*When using Ash's atomic operations globally, transfer updates need special handling to lock accounts before updating.*

### 6. ULID Usage for Balance Snapshots

```elixir
# Generate a ULID for a specific timestamp
ulid = AshDoubleEntry.ULID.generate(timestamp)

# Get balance as of a specific ULID
# ULIDs are time-sortable, allowing "balance as of" queries
last_ulid = AshDoubleEntry.ULID.bingenerate_last(timestamp)

# Query balances up to a specific point in time
YourApp.Ledger.Balance
|> Ash.Query.filter(id <= ^last_ulid)
|> Ash.read!()
```

*ULIDs provide time-based ordering for balance snapshots, enabling historical balance queries.*

### 7. Creating an Account

```elixir
# Open a new account using the auto-generated action
YourApp.Ledger.Account
|> Ash.Changeset.for_create(:open, %{account_number: "ACC-001"})
|> Ash.create!()
```

*The `open` action is automatically created by the Account extension.*

### 8. Creating a Transfer Between Accounts

```elixir
# Create a transfer from one account to another
YourApp.Ledger.Transfer
|> Ash.Changeset.for_create(:create, %{
  from_account_id: from_account.id,
  to_account_id: to_account.id,
  amount: Money.new(:USD, "100.00")
})
|> Ash.create!()
```

*Transfers automatically update balances for both accounts involved.*

### 9. Complete Setup with AshMoney

```elixir
# In mix.exs - Add dependencies
defp deps do
  [
    {:ash_double_entry, "~> 1.0.3"},
    {:ash_money, "~> 0.1"},
    {:ex_money_sql, "~> 1.0"}  # Required for AshPostgres
  ]
end

# In config/config.exs - Configure AshMoney
config :ex_money,
  default_cldr_backend: YourApp.Cldr

# Define your CLDR backend
defmodule YourApp.Cldr do
  use Cldr,
    locales: ["en"],
    providers: [Cldr.Number, Money]
end
```

*Complete setup including AshMoney integration for proper currency handling.*

### 10. Generating and Running Migrations

```bash
# Generate migrations for your double-entry ledger
mix ash_postgres.generate_migrations --name add_double_entry_ledger

# Run the migrations
mix ash_postgres.migrate
```

*Create database tables for accounts, transfers, and balances.*

## Reference Files

This skill includes comprehensive documentation in `references/`:

### accounting.md
Complete reference documentation extracted from HexDocs covering:
- **AshDoubleEntry.Account** - DSL options and configuration for account resources
- **AshDoubleEntry.Transfer** - Transfer resource extension details
- **AshDoubleEntry.Balance** - Balance tracking and querying
- **AshDoubleEntry.ULID** - Time-sortable unique identifiers for balance versioning
- **Getting Started Guide** - Complete setup instructions with examples
- **Integration Notes** - AshMoney setup, migration generation, atomic operations

### book-domain-modeling.md
Excerpt from "Ash Framework: Domain Modeling" covering:
- Domain modeling principles applicable to financial systems
- Resource and relationship design patterns
- Attributes, identities, and validations
- Actions and lifecycle callbacks
- Testing strategies for Ash applications

### book-pragmatic-ash.md
Excerpt from "Ash Framework: Create Declarative Elixir Web Apps" covering:
- Building real-world Ash applications
- Advanced resource patterns
- API generation (REST/GraphQL)
- Authentication and authorization with Ash
- Testing best practices

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners

1. **Start with the Getting Started section** in `accounting.md`
2. **Review the Quick Reference examples** above to understand the basic structure
3. **Follow the setup steps** to integrate AshMoney and create your first resources
4. **Experiment with creating accounts and transfers** in IEx

Key beginner concepts:
- Understand the three core resources (Account, Transfer, Balance)
- Learn how transfers automatically update balances
- Grasp the relationship between the three resources

### For Intermediate Users

1. **Customize your resources** by adding attributes, validations, and custom actions
2. **Implement business logic** using Ash's change and validation system
3. **Build code interfaces** for cleaner API access to your ledger
4. **Add authorization policies** to control who can create accounts and transfers

Intermediate patterns:
- Custom account types (asset, liability, revenue, expense)
- Multi-currency support with proper exchange rates
- Balance snapshots and historical reporting
- Audit trails and transaction logging

### For Advanced Users

1. **Implement complex financial workflows** with custom actions and changes
2. **Build reporting aggregates** for financial statements
3. **Create custom extensions** for domain-specific accounting rules
4. **Optimize queries** for balance calculations and reporting
5. **Implement multi-tenancy** for multiple ledgers

Advanced topics:
- Custom balance calculations and aggregations
- Performance optimization for large transaction volumes
- Integration with external financial systems
- Complex authorization rules for financial operations
- Atomic operations and race condition handling

### Navigation Tips

- **Quick answers**: Use the Quick Reference section for common patterns
- **Setup help**: Check `accounting.md` for installation and configuration
- **Deep dives**: Read the book excerpts for architectural guidance
- **Troubleshooting**: Review atomic operations and locking mechanisms
- **Examples**: All code examples are runnable - try them in your project

## Common Patterns

### Pattern 1: Multi-Currency Ledger

```elixir
# Account with currency specification
attribute :currency, :atom do
  constraints [one_of: [:USD, :EUR, :GBP]]
  allow_nil? false
end

# Validate transfers use matching currencies
validate fn changeset, _ ->
  from = Ash.Changeset.get_argument(changeset, :from_account)
  to = Ash.Changeset.get_argument(changeset, :to_account)

  if from.currency != to.currency do
    {:error, field: :to_account, message: "Currency mismatch"}
  else
    :ok
  end
end
```

### Pattern 2: Account Types

```elixir
# Add account type classification
attribute :account_type, :atom do
  constraints [one_of: [:asset, :liability, :revenue, :expense, :equity]]
  allow_nil? false
end

# Define type-specific validation rules
```

### Pattern 3: Balance As Of Date

```elixir
# Get account balance at a specific point in time
def balance_as_of(account_id, datetime) do
  timestamp = DateTime.to_unix(datetime, :millisecond)
  ulid = AshDoubleEntry.ULID.bingenerate_last(timestamp)

  YourApp.Ledger.Balance
  |> Ash.Query.filter(account_id == ^account_id and id <= ^ulid)
  |> Ash.Query.sort(id: :desc)
  |> Ash.Query.limit(1)
  |> Ash.read_one!()
end
```

## Resources

### Official Documentation
- [Hex Package](https://hex.pm/packages/ash_double_entry)
- [HexDocs](https://hexdocs.pm/ash_double_entry/)
- [Ash Framework](https://ash-hq.org/)

### Related Libraries
- **AshMoney** - Money type support with currency handling
- **AshPostgres** - PostgreSQL data layer
- **AshAuthentication** - User authentication for multi-user ledgers
- **AshGraphQL/AshJsonApi** - API generation for ledger access

### Learning Resources
- Getting Started guide in `references/accounting.md`
- Domain modeling patterns in `references/book-domain-modeling.md`
- Real-world application patterns in `references/book-pragmatic-ash.md`

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve structure and examples from source docs
- Code examples include proper language detection for syntax highlighting
- All examples are tested and runnable
- The library requires AshMoney for proper money/currency handling
- PostgreSQL users should use `ex_money_sql` for proper database money types

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
3. Verify examples still work with the new version

## Troubleshooting

### Common Issues

**Issue**: Migrations fail with money type errors
**Solution**: Ensure `ex_money_sql` is installed and configured

**Issue**: Balance updates not atomic
**Solution**: Add `get_and_lock_for_update()` change and `require_atomic? false`

**Issue**: Cascade deletion not working
**Solution**: Add `references` block in postgres DSL with `on_delete: :delete`

**Issue**: ULIDs not sorting correctly
**Solution**: Ensure you're using binary ULIDs (`bingenerate`) not string ULIDs

For more help, consult the reference documentation or the Ash community forums.
