# Ash-Postgres - Migrations

**Pages:** 4

---

## Schema Based Multitenancy

**URL:** https://hexdocs.pm/ash_postgres/schema-based-multitenancy.html

**Contents:**
- Schema Based Multitenancy
- Generated migrations
- Automatically managing tenants

Multitenancy in AshPostgres is implemented via postgres schemas. For more information on schemas, see postgres' schema documentation

Implementing multitenancy via schema's involves tracking "tenant migrations" separately from migrations for your public schema. You can see what this looks like by simply creating a multitenant resource, and using the migration generator mix ash.codegen. It will put schema specific migrations in priv/repo/tenant_migrations. When you generate migrations, you'll want to be sure to audit migrations in both directories. Additionally, when you deploy, you'll want to run your migrations, as well as running them with the migrations path priv/repo/tenant_migrations.

The generated migrations include a lot of niceties around multitenancy. Specifically, foreign keys will point at tables in the correct schema, and foreign keys to non-multitenant resources will point to the correct table. If you are using attribute multitenancy, foreign keys to tables also using attribute multitenancy will be composite foreign keys, including the tenant attribute as well as the referencing field.

Migrations in the tenant directory will call repo().all_tenants(), which is a callback you will need to implement in your repo that should return a list of all schemas that need to be migrated.

For example, if you use the manage_tenant directive described below, you could do:

By setting the template configuration, in the manage_tenant section, you can cause the creation/updating of a given resource to create/rename tenants. For example:

With this configuration, if you create an organization, it will create a corresponding schema, e.g. org_10 in the database. Then it will run your tenant migrations on that schema. To override the tenant_migrations path, implement the AshPostgres.Repo.tenant_migrations_path/0 callback.

Notice that manage_tenant is nested inside the postgres block. This is because the method of managing tenants is specific to postgres, and if another data layer supported multitenancy they may or may not support managing tenants in the same way.

Hex Package Hex Preview (current file) Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (python):
```python
defmodule Myapp.Repo do
  use AshPostgres.Repo, ...

  import Ecto.Query, only: [from: 2]

  ...

  def all_tenants do
    all(from(row in "organizations", select: fragment("? || ?", "org_", row.id)))
  end
end
```

Example 2 (unknown):
```unknown
defmodule MyApp.Organization do
  use Ash.Resource,
    ...

  postgres do
    ...

    manage_tenant do
      template ["org_", :id]
    end
  end
end
```

---

## mix ash_postgres.migrate (ash_postgres v2.6.23)

**URL:** https://hexdocs.pm/ash_postgres/Mix.Tasks.AshPostgres.Migrate.html

**Contents:**
- mix ash_postgres.migrate (ash_postgres v2.6.23)
- Examples
- Command line options

Runs the pending migrations for the given repository.

Migrations are expected at "priv/YOUR_REPO/migrations" directory of the current application (or tenant_migrations for multitenancy), where "YOUR_REPO" is the last segment in your repository name. For example, the repository MyApp.Repo will use "priv/repo/migrations". The repository Whatever.MyRepo will use "priv/my_repo/migrations".

This task runs all pending migrations by default. To migrate up to a specific version number, supply --to version_number. To migrate a specific number of times, use --step n.

If you have multiple repos and you want to run a single migration and/or migrate them to different points, you will need to use the ecto specific task, mix ecto.migrate and provide your repo name.

If a repository has not yet been started, one will be started outside your application supervision tree and shutdown afterwards.

--domains - the domains who's repos should be migrated

--tenants - Run the tenant migrations

--only-tenants - in combo with --tenants, only runs migrations for the provided tenants, e.g tenant1,tenant2,tenant3

--except-tenants - in combo with --tenants, does not run migrations for the provided tenants, e.g tenant1,tenant2,tenant3

--all - run all pending migrations

--repo, -r - the repo to migrate

--step, -n - run n number of pending migrations

--to - run all migrations up to and including version

--quiet - do not log migration commands

--prefix - the prefix to run migrations on. This is ignored if --tenants is provided.

--pool-size - the pool size if the repository is started only for the task (defaults to 2)

--log-migrations-sql - log SQL generated by migration commands

--log-migrator-sql - log SQL generated by the migrator, such as transactions, table locks, etc

--strict-version-order - abort when applying a migration with old timestamp

--no-compile - does not compile applications before migrating

--no-deps-check - does not check dependencies before migrating

--migrations-path - the path to load the migrations from, defaults to "priv/repo/migrations". This option may be given multiple times in which case the migrations are loaded from all the given directories and sorted as if they were in the same one.

Note, if you have migrations paths e.g. a/ and b/, and run mix ecto.migrate --migrations-path a/, the latest migrations from a/ will be run (even if b/ contains the overall latest migrations.)

Hex Package Hex Preview Search HexDocs Download ePub version

Built

*[Content truncated]*

**Examples:**

Example 1 (unknown):
```unknown
mix ash_postgres.migrate
mix ash_postgres.migrate --domains MyApp.Domain1,MyApp.Domain2

mix ash_postgres.migrate -n 3
mix ash_postgres.migrate --step 3

mix ash_postgres.migrate --to 20080906120000
```

---

## mix ash_postgres.generate_migrations (ash_postgres v2.6.23)

**URL:** https://hexdocs.pm/ash_postgres/Mix.Tasks.AshPostgres.GenerateMigrations.html

**Contents:**
- mix ash_postgres.generate_migrations (ash_postgres v2.6.23)
    - Snapshots
    - Dropping columns
    - Conflicts/Multiple Resources
    - Defaults
    - Identities
- Summary
- Functions
- Functions
- run(args)

Generates migrations, and stores a snapshot of your resources.

Snapshots are stored in a folder for each table that migrations are generated for. Each snapshot is stored in a file with a timestamp of when it was generated. This is important because it allows for simultaneous work to be done on separate branches, and for rolling back changes more easily, e.g removing a generated migration, and deleting the most recent snapshot, without having to redo all of it

Generally speaking, it is bad practice to drop columns when you deploy a change that would remove an attribute. The main reasons for this are backwards compatibility and rolling restarts. If you deploy an attribute removal, and run migrations. Regardless of your deployment strategy, you won't be able to roll back, because the data has been deleted. In a rolling restart situation, some of the machines/pods/whatever may still be running after the column has been deleted, causing errors. With this in mind, its best not to delete those columns until later, after the data has been confirmed unnecessary. To that end, you can pass --dont-drop-columns to tell it to comment out those statements.

The migration generator can support multiple schemas using the same table. It will raise on conflicts that it can't resolve, like the same field with different types. It will prompt to resolve conflicts that can be resolved with human input. For example, if you remove an attribute and add an attribute, it will ask you if you are renaming the column in question. If not, it will remove one column and add the other.

Additionally, it lowers things to the database where possible:

There are three anonymous functions that will translate to database-specific defaults currently:

Non-function default values will be dumped to their native type and inspected. This may not work for some types, and may require manual intervention/patches to the migration generator code.

Identities will cause the migration generator to generate unique constraints. If multiple resources target the same table, you will be asked to select the primary key, and any others will be added as unique constraints.

Callback implementation for Mix.Task.run/1.

Callback implementation for Mix.Task.run/1.

Hex Package Hex Preview Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

---

## Migrations

**URL:** https://hexdocs.pm/ash_postgres/migrations-and-tasks.html

**Contents:**
- Migrations
- Tasks
- Basic Workflow
  - all_tenants/0
- Running Migrations in Production
  - AshPostgres-specific mix tasks

Ash comes with its own tasks, and AshPostgres exposes lower level tasks that you can use if necessary. This guide shows the process using ash.* tasks, and the ash_postgres.* tasks are illustrated at the bottom.

The --dev workflow enables you to avoid having to think of a name for migrations while developing, and also enables some upcoming workflows that will detect when code generation needs to be run on page load and will show you a button to generate dev migrations and run them.

For more information on generating migrations, run mix help ash_postgres.generate_migrations (the underlying task that is called by mix ash.migrate)

If you have are using schema-based multitenancy, you will also need to define a all_tenants/0 function in your repo module. See AshPostgres.Repo for more.

Define a module similar to the following:

Hex Package Hex Preview (current file) Search HexDocs Download ePub version

Built using ExDoc (v0.38.4) for the Elixir programming language

**Examples:**

Example 1 (python):
```python
defmodule MyApp.Release do
  @moduledoc """
Tasks that need to be executed in the released application (because mix is not present in releases).
  """
  @app :my_app
  def migrate do
    load_app()

    for repo <- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))
    end
  end

  # only needed if you are using postgres multitenancy
  def migrate_tenants do
    load_app()

    for repo <- repos() do
      path = Ecto.Migrator.migrations_path(repo, "tenant_migrations")
      # This may be different for you if you are not using the default tenan
...
```

---
