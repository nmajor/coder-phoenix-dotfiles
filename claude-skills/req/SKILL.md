---
name: req
description: Req HTTP client reference (fallback reference - use external-api-integration skill). Do not use directly; this provides underlying Req client documentation.
---

# Req Skill

Comprehensive assistance with req development, generated from official documentation.

## When to Use This Skill

This skill should be triggered when:
- Working with req
- Asking about req features or APIs
- Implementing req solutions
- Debugging req code
- Learning req best practices

## Quick Reference

### Common Patterns

**Pattern 1:** default_options() @spec default_options() :: keyword() Returns default options.See default_options/1 for more information. default_options(options) @spec default_options(keyword()) :: :ok Sets default options for Req.new/1.Avoid setting default options in libraries as they are global.Examplesiex> Req.default_options(base_url: "https://httpbin.org") iex> Req.get!("/statuses/201").status 201 iex> Req.new() |> Req.get!(url: "/statuses/201").status 201 get_headers_list(struct) (since 0.5.10) @spec get_headers_list(Req.Request.t() | Req.Response.t()) :: [{binary(), binary()}] Returns request/response headers as list.Examplesiex> req = Req.Request.new(headers: %{"accept" => ["application/json"]}) iex> Req.get_headers_list(req) [{"accept", "application/json"}] iex> resp = Req.Response.new(headers: %{"content-type" => ["application/json"]}) iex> Req.get_headers_list(resp) [{"content-type", "application/json"}] merge(request, options) @spec merge(Req.Request.t(), options :: keyword()) :: Req.Request.t() Updates a request struct.See new/1 for a list of available options. Also see Req.Request module documentation for more information on the underlying request struct.Examplesiex> req = Req.new(base_url: "https://httpbin.org") iex> req = Req.merge(req, auth: {:basic, "alice:secret"}) iex> req.options[:base_url] "https://httpbin.org" iex> req.options[:auth] {:basic, "alice:secret"}Passing :headers will automatically encode and merge them:iex> req = Req.new(headers: %{point_x: 1}) iex> req = Req.merge(req, headers: %{point_y: 2}) iex> req.headers %{"point-x" => ["1"], "point-y" => ["2"]}The same header names are overwritten however:iex> req = Req.new(headers: %{authorization: "bearer foo"}) iex> req = Req.merge(req, headers: %{authorization: "bearer bar"}) iex> req.headers %{"authorization" => ["bearer bar"]}Similarly to headers, :params are merged too:req = Req.new(url: "https://httpbin.org/anything", params: [a: 1, b: 1]) req = Req.merge(req, params: [a: 2]) Req.get!(req).body["args"] #=> %{"a" => "2", "b" => "1"} new(options \\ []) @spec new(options :: keyword()) :: Req.Request.t() Returns a new request struct with built-in steps.See request/2, run/2, as well as get/2, post/2, and similar functions for making requests.Also see Req.Request module documentation for more information on the underlying request struct.OptionsBasic request options::method - the request method, defaults to :get.:url - the request URL.:headers - the request headers as a {key, value} enumerable (e.g. map, keyword list).The header names should be downcased.The headers are automatically encoded using these rules:atom header names are turned into strings, replacing _ with -. For example, :user_agent becomes "user-agent".string header names are downcased.%DateTime{} header values are encoded as "HTTP date".If you set :headers options both in Req.new/1 and request/2, the header lists are merged.See also "Headers" section in the module documentation.:body - the request body.Can be one of:iodata - send request body eagerlyenumerable - stream enumerable as request bodyAdditional URL options::base_url - if set, the request URL is prepended with this base URL (via put_base_url step.):params - if set, appends parameters to the request query string (via put_params step.):path_params - if set, uses a templated request path (via put_path_params step.):path_params_style (available since v0.5.1) - how path params are expressed (via put_path_params step). Can be one of::colon - (default) for Plug-style parameters, such as :code in https://httpbin.org/status/:code.:curly - for OpenAPI-style parameters, such as {code} in https://httpbin.org/status/{code}.Authentication options::auth - sets request authentication (via auth step.)Can be one of:{:basic, userinfo} - uses Basic HTTP authentication.{:bearer, token} - uses Bearer HTTP authentication.:netrc - load credentials from the default .netrc file.{:netrc, path} - load credentials from path.string - sets to this value.&fun/0 - a function that returns one of the above (such as a {:bearer, token}).Request body encoding options (encode_body)::form - if set, encodes the request body as application/x-www-form-urlencoded:form_multipart - if set, encodes the request body as multipart/form-data.:json - if set, encodes the request body as JSONOther request body options::compress_body - if set to true, compresses the request body using gzip (via compress_body step.) Defaults to false.AWS Signature Version 4 options (put_aws_sigv4 step)::aws_sigv4 - if set, the AWS options to sign request::access_key_id - the AWS access key id.:secret_access_key - the AWS secret access key.:service - the AWS service.:region - if set, AWS region. Defaults to "us-east-1".:datetime - the request datetime, defaults to DateTime.utc_now(:second).Response body options::compressed - if set to true, asks the server to return compressed response. (via compressed step.) Defaults to true.:raw - if set to true, disables automatic body decompression (decompress_body step) and decoding (decode_body step.) Defaults to false.:decode_body - if set to false, disables automatic response body decoding. Defaults to true.:decode_json - options to pass to Jason.decode!/2, defaults to [].:into - where to send the response body. It can be one of:nil - (default) read the whole response body and store it in the response.body field.fun - stream response body using a function. The first argument is a {:data, data} tuple containing the chunk of the response body. The second argument is a {request, response} tuple. To continue streaming chunks, return {:cont, {req, resp}}. To cancel, return {:halt, {req, resp}}. For example:into: fn {:data, data}, {req, resp} -> IO.puts(data) {:cont, {req, resp}} endcollectable - stream response body into a Collectable.t/0. For example: into: File.stream!("path")Note that the collectable is only used, if the response status is 200. In other cases, the body is accumulated and processed as usual.:self - stream response body into the current process mailbox.Received messages should be parsed with Req.parse_message/2.response.body is set to opaque data structure Req.Response.Async which implements Enumerable that receives and automatically parses messages. See module documentation for example usage.If the request is sent using HTTP/1, an extra process is spawned to consume messages from the underlying socket. On both HTTP/1 and HTTP/2 the messages are sent to the current process as soon as they arrive, as a firehose. If you wish to maximize request rate or have more control over how messages are streamed, use into: fun or into: collectable instead.Response redirect options (redirect step)::redirect - if set to false, disables automatic response redirects. Defaults to true.:redirect_trusted - by default, authorization credentials are only sent on redirects with the same host, scheme and port. If :redirect_trusted is set to true, credentials will be sent to any host.:max_redirects - the maximum number of redirects, defaults to 10.Other response options::http_errors - how to handle HTTP 4xx/5xx error responses (via handle_http_errors step). Can be one of the following::return (default) - return the response:raise - raise an errorRetry options (retry step)::retry - can be one of the following::safe_transient (default) - retry safe (GET/HEAD) requests on one of:HTTP 408/429/500/502/503/504 responsesReq.TransportError with reason: :timeout | :econnrefused | :closedReq.HTTPError with protocol: :http2, reason: :unprocessed:transient - same as :safe_transient except retries all HTTP methods (POST, DELETE, etc.)fun - a 2-arity function that accepts a Req.Request and either a Req.Response or an exception struct and returns one of the following:true - retry with the default delay controller by default delay option described below.{:delay, milliseconds} - retry with the given delay.false/nil - don't retry.false - don't retry.:retry_delay - if not set, which is the default, the retry delay is determined by the value of the Retry-After header on HTTP 429/503 responses. If the header is not set, the default delay follows a simple exponential backoff: 1s, 2s, 4s, 8s, ...:retry_delay can be set to a function that receives the retry count (starting at 0) and returns the delay, the number of milliseconds to sleep before making another attempt.:retry_log_level - the log level to emit retry logs at. Can also be set to false to disable logging these messages. Defaults to :warning.:max_retries - maximum number of retry attempts, defaults to 3 (for a total of 4 requests to the server, including the initial one.)Caching options (cache step)::cache - if true, performs HTTP caching. Defaults to false.:cache_dir - the directory to store the cache, defaults to <user_cache_dir>/req (see: :filename.basedir/3)Request adapters::adapter - adapter to use to make the actual HTTP request. See :adapter field description in the Req.Request module documentation for more information.The default is run_finch.:plug - if set, calls the given plug instead of making an HTTP request over the network (via run_plug step).The plug can be one of:A function plug: a fun(conn) or fun(conn, options) function that takes a Plug.Conn and returns a Plug.Conn.A module plug: a module name or a {module, options} tuple.Finch options (run_finch step), see Finch.start_link/1 for options::finch - the Finch pool to use. Defaults to pool automatically started by Req.:connect_options - dynamically starts (or re-uses already started) Finch pool with the given connection options (see Mint.HTTP.connect/4 for options)::timeout - socket connect timeout in milliseconds, defaults to 30_000.:protocols - the HTTP protocols to use, defaults to [:http1].:hostname - Mint explicit hostname.:transport_opts - Mint transport options.:proxy_headers - Mint proxy headers.:proxy - Mint HTTP/1 proxy settings, a {schema, address, port, options} tuple.:client_settings - Mint HTTP/2 client settings.:inet6 - if set to true, uses IPv6. Defaults to false.:pool_timeout - pool checkout timeout in milliseconds, defaults to 5000.:receive_timeout - socket receive timeout in milliseconds, defaults to 15_000.:unix_socket - if set, connect through the given UNIX domain socket.:pool_max_idle_time - the maximum number of milliseconds that a pool can be idle before being terminated, used only by HTTP1 pools. Default to :infinity.:finch_private - a map or keyword list of private metadata to add to the Finch request. May be useful for adding custom data when handling telemetry with Finch.Telemetry.:finch_request - a function that executes the Finch request, defaults to using Finch.request/3.Examplesiex> req = Req.new(url: "https://elixir-lang.org") iex> req.method :get iex> URI.to_string(req.url) "https://elixir-lang.org"Fake adapter:iex> fake = fn request -> ...> {request, Req.Response.new(status: 200, body: "it works!")} ...> end iex> iex> req = Req.new(adapter: fake) iex> Req.get!(req).body "it works!"

```
@spec default_options() :: keyword()
```

**Pattern 2:** fun - stream response body using a function. The first argument is a {:data, data} tuple containing the chunk of the response body. The second argument is a {request, response} tuple. To continue streaming chunks, return {:cont, {req, resp}}. To cancel, return {:halt, {req, resp}}. For example:

```
fun
```

**Pattern 3:** collectable - stream response body into a Collectable.t/0. For example:

```
collectable
```

**Pattern 4:** Req.Request (req v0.5.15) View Source The low-level API and the request struct.Req is composed of:Req - the high-level APIReq.Request - the low-level API and the request struct (you're here!)Req.Steps - the collection of built-in stepsReq.Test - the testing conveniencesThe low-level API and the request struct is the foundation of Req's extensibility. Virtually all of the functionality is broken down into individual pieces - steps. Req works by running the request struct through these steps. You can easily reuse or rearrange built-in steps or write new ones.To make using custom steps by others even easier, they can be packaged up into plugins. See "Writing Plugins" section for more information.The Low-level APIMost Req users would use it like this:Req.get!("https://api.github.com/repos/wojtekmach/req").body["description"] #=> "Req is a batteries-included HTTP client for Elixir."Here is the equivalent using the low-level API:url = "https://api.github.com/repos/wojtekmach/req" req = Req.Request.new(method: :get, url: url) |> Req.Request.append_request_steps( put_user_agent: &Req.Steps.put_user_agent/1, # ... ) |> Req.Request.append_response_steps( # ... decompress_body: &Req.Steps.decompress_body/1, decode_body: &Req.Steps.decode_body/1, # ... ) |> Req.Request.append_error_steps( retry: &Req.Steps.retry/1, # ... ) {req, resp} = Req.Request.run_request(req) resp.body["description"] #=> "Req is a batteries-included HTTP client for Elixir."By putting the request pipeline yourself you have precise control of exactly what is running and in what order.The Request StructPublic fields are::method - the HTTP request method.:url - the HTTP request URL.:headers - the HTTP request headers. The header names should be downcased. See also "Headers" section in Req module documentation.:body - the HTTP request body.Can be one of:iodata - eagerly send request bodyenumerable - stream request body:into - where to send the response body. It can be one of:nil - (default) read the whole response body and store it in the response.body field.fun - stream response body using a function. The first argument is a {:data, data} tuple containing the chunk of the response body. The second argument is a {request, response} tuple. To continue streaming chunks, return {:cont, {req, resp}}. To cancel, return {:halt, {req, resp}}. For example:into: fn {:data, data}, {req, resp} -> IO.puts(data) {:cont, {req, resp}} endcollectable - stream response body into a Collectable.t/0. For example:into: File.stream!("path")Note that the collectable is only used, if the response status is 200. In other cases, the body is accumulated and processed as usual.:options - the options to be used by steps. The exact representation of options is private. Calling request.options[key], put_in(request.options[key], value), and update_in(request.options[key], fun) is allowed. get_option/3 and delete_option/2 are also available for additional ways to manipulate the internal representation.:halted - whether the request pipeline is halted. See halt/2.:adapter - a request step that makes the actual HTTP request. Defaults to Req.Steps.run_finch/1. See "Adapter" section below for more information.:request_steps - the list of request steps:response_steps - the list of response steps:error_steps - the list of error steps:private - a map reserved for libraries and frameworks to use. The keys must be atoms. Prefix the keys with the name of your project to avoid any future conflicts. The req_ prefix is reserved for Req.StepsReq has three types of steps: request, response, and error.Request steps are used to refine the data that will be sent to the server.After making the actual HTTP request, we'll either get a HTTP response or an error. The request, along with the response or error, will go through response or error steps, respectively.Nothing is actually executed until we run the pipeline with Req.Request.run_request/1.Request StepsA request step (request_step/0) is a function that accepts a request and returns one of the following:A request.A {request, response_or_error} tuple. In this case no further request steps are executed and the return value goes through response or error steps.ExamplesA request step that adds a user-agent header if it's not there already:def put_default_headers(request) do Req.Request.put_new_header(request, "user-agent", "req") endThe next is a request step that reads the response from cache if available. Note how, if the cached response is available, this step returns a {request, response} tuple so that the request doesn't actually go through:def read_from_cache(request) do case ResponseCache.fetch(request) do {:ok, response} -> {request, response} :error -> request end endResponse and Error StepsA response step (response_step/0) is a function that accepts a {request, response} tuple and returns one of the following:A {request, response} tuple.A {request, exception} tuple. In that case, no further response steps are executed but the exception goes through error steps.Similarly, an error step is a function that accepts a {request, exception} tuple and returns one of the following:A {request, exception} tupleA {request, response} tuple. In that case, no further error steps are executed but the response goes through response steps.Examples:def decode({request, response}) do case Req.Response.get_header(response, "content-type") do ["application/json" <> _] -> {request, update_in(response.body, &Jason.decode!/1)} [] -> {request, response} end end def log_error({request, exception}) do Logger.error(["#{request.method} #{request.uri}: ", Exception.message(exception)]) {request, exception} endHaltingAny step can call halt/2 to halt the pipeline. This prevents any further steps from being invoked.Examples:def circuit_breaker(request) do if CircuitBreaker.open?() do Req.Request.halt(request, RuntimeError.exception("circuit breaker is open")) else request end endWriting PluginsCustom steps can be packaged into plugins so that they are even easier to use by others.Here's an example plugin:defmodule PrintHeaders do @doc """ Prints request and response headers. ## Request Options * `:print_headers` - if `true`, prints the headers. Defaults to `false`. """ def attach(%Req.Request{} = request, options \\ []) do request |> Req.Request.register_options([:print_headers]) |> Req.Request.merge_options(options) |> Req.Request.append_request_steps(print_headers: &print_request_headers/1) |> Req.Request.prepend_response_steps(print_headers: &print_response_headers/1) end defp print_request_headers(request) do if request.options[:print_headers] do print_headers("> ", request.headers) end request end defp print_response_headers({request, response}) do if request.options[:print_headers] do print_headers("< ", response.headers) end {request, response} end defp print_headers(prefix, headers) do for {name, value} <- headers do IO.puts([prefix, name, ": ", value]) end end endAnd here is how we can use it:req = Req.new() |> PrintHeaders.attach() Req.get!(req, url: "https://httpbin.org/json").status 200 Req.get!(req, url: "https://httpbin.org/json", print_headers: true).status # Outputs: # > accept-encoding: br, gzip # > user-agent: req/0.3.0-dev # < date: Wed, 11 May 2022 11:10:47 GMT # < content-type: application/json # ... 200 req = Req.new() |> PrintHeaders.attach(print_headers: true) Req.get!(req, url: "https://httpbin.org/json").status # Outputs: # > accept-encoding: br, gzip # ... 200As you can see a plugin is simply a module. While this is not enforced, the plugin should follow these conventions:It should export an attach/1 function that takes and returns the request structThe attach functions mostly just adds steps and it is the steps that do the actual workA user should be able to attach your plugin alongside other plugins. For this reason, plugin functionality should usually only happen on a specific "trigger": on a specific option, on a specific URL scheme or host, etc. This is especially important for plugins that perform authentication; you don't want to accidentally expose a token from service A when a user makes request to service B.If your plugin supports custom options, register them with register_options/2Sometimes it is useful to pass options when attaching the plugin. For that, export an attach/2 function and call merge_options/2. Remember to first register options before merging!AdapterAs noted in the "Request Steps" section, a request step besides returning the request, might also return {request, response} or {request, exception}, thus invoking either response or error steps next. This is exactly how Req makes the underlying HTTP call, by invoking a request step that follows this contract.The default adapter is using Finch via the Req.Steps.run_finch/1 step.Here is a mock adapter that always returns a successful response:adapter = fn request -> response = %Req.Response{status: 200, body: "it works!"} {request, response} end Req.request!(url: "http://example", adapter: adapter).body #=> "it works!"Here is another one that uses the Req.Response.json/2 function to conveniently return a JSON response:adapter = fn request -> response = Req.Response.json(%{hello: 42}) {request, response} end resp = Req.request!(url: "http://example", adapter: adapter) resp.headers #=> [{"content-type", "application/json"}] resp.body #=> %{"hello" => 42}And here is a naive Hackney-based adapter:hackney = fn request -> case :hackney.request( request.method, URI.to_string(request.url), request.headers, request.body, [:with_body] ) do {:ok, status, headers, body} -> headers = for {name, value} <- headers, do: {String.downcase(name, :ascii), value} response = %Req.Response{status: status, headers: headers, body: body} {request, response} {:error, reason} -> {request, RuntimeError.exception(inspect(reason))} end end Req.get!("https://api.github.com/repos/wojtekmach/req", adapter: hackney).body["description"] #=> "Req is a batteries-included HTTP client for Elixir."

```
Req
```

**Pattern 5:** CHANGELOG View Source v0.5.15 (2025-07-14)Req.Response: Add Req.Response.to_map/1.v0.5.14 (2025-07-02)run_plug: Remove warning about into: fun with {:halt, acc} result.The warning never been particularly useful because it's not like users can do anything about it.v0.5.13 (2025-07-02)run_plug: Ease transition to automatically parsing request body.Since v0.5.11, this code:plug = fn conn -> {:ok, body, conn} = Plug.Conn.read_body(conn) assert JSON.decode!(body) == %{"x" => 1} Plug.Conn.send_resp(conn, 200, "ok") end Req.put!(plug: plug, json: %{x: 1}) Needed to be updated to:plug = fn conn -> assert conn.body_params == %{"x" => 1} Plug.Conn.send_resp(conn, 200, "ok") end Req.put!(plug: plug, json: %{x: 1})This change makes it so both work. The latter will be required, however.v0.5.12 (2025-06-24)run_plug: Do not raise on unknown content types.Req.Test: Improve Req.Test.transport_error/2 error message.v0.5.11 (2025-06-23)encode_body: Fix leading newline before multipart body.run_finch: Handle initial transport errors on into: :self.run_plug: Automatically parse request body.Prior to this change, users would typically write:plug = fn conn -> {:ok, body, conn} = Plug.Conn.read_body(conn) assert JSON.decode!(body) == %{"x" => 1} Plug.Conn.send_resp(conn, 200, "ok") end Req.put!(plug: plug, json: %{x: 1})Now, it can be:plug = fn conn -> assert conn.params == %{"x" => 1} Plug.Conn.send_resp(conn, 200, "ok") end Req.put!(plug: plug, json: %{x: 1})This is a breaking change as Plug.Conn.read_body will now return "".It can be easily fixed by using Req.Test.raw_body/1 which returns copy of the request raw body:- {:ok, body, conn} = Plug.Conn.read_body(conn) + body = Req.Test.raw_body(conn)Furthermore, prior to this change conn.body_params was unfetched:plug = fn conn -> Plug.Conn.send_resp(conn, 200, inspect(conn.body_params)) end iex> Req.post!(json: %{a: 1}, plug: plug).body "%Plug.Conn.Unfetched{aspect: :body_params}"Now it is:iex> Req.post!(json: %{a: 1}, plug: plug).body "%{\"a\": 1}"If in your :plug usage you look at conn.params, it will now include conn.body_params as Plug always merges them.retry: Use jitter by defaultReq.Request: Add Req.Request.put_option/3.Req.Request: Add Req.Request.put_new_option/3.Req.Request: Add Req.Request.merge_new_options/2.Req.Test: Add [Req.Test.redirect/2].v0.5.10 (2025-03-21)Req: Add Req.get_headers_list/1.v0.5.9 (2025-03-17)encode_body: Support any enumerable in :form_multipartReq.Test.expect/3: Fix usage in shared moderetry: Do not carry halt between retries(Internal) Support custom headers in Req.Utils.aws_sigv4_url/1(Internal) Support custom query params in Req.Utils.aws_sigv4_url/1v0.5.8 (2024-11-29)Req: Check legacy headers when streaming headersReq: Ignore :into collectable for non-200 responsesput_aws_sigv4: Fix encoding pathrun_finch: Add option to configure Finch :pool_max_idle_timerun_finch: Prepare for upcoming Finch v0.20v0.5.7 (2024-10-29)put_aws_sigv4: Fix signature when using custom portretry: Do not call retry_delay fun twiceauth: Support passing a 0-arity functionv0.5.6 (2024-08-01)Fix compatibility with Elixir v1.13v0.5.5 (2024-08-01)put_aws_sigv4: Fix detecting serviceput_aws_sigv4: Raise on no :access_key_id/:secret_access_key/:serviceput_aws_sigv4: Fix handling ?name (no value)handle_http_errors: should run before verify_checksumencode_body: Support %File.Stream{} in :form_multipartencode_body: Support %File.Stream{} from other nodes in :form_multipartv0.5.4 (2024-07-18)run_finch, Req.parse_message/2: Gracefully handle process messages not meant for the asynchronous response. In that case, Req.parse_message/2 returns :unknown.v0.5.3 (2024-07-18)Req.Test: Fix using shared modeencode_body: Add :form_multipart optionput_aws_sigv4: Try detecting the servicerun_finch: Fix setting :finch optionv0.5.2 (2024-07-08)put_aws_sigv4: Fix bug when using custom headersput_aws_sigv4: Add :token optionredirect: Cancel async request before redirectingdecode_body: Support application/zstd and .zstv0.5.1 (2024-06-24)retry: Default :retry_log_level to :warningput_path_params: Add :path_params_style optionput_aws_sigv4: Fix path encodingdecode_body: Improve tar detectionrun_finch: Fix defaulting to using just HTTP/1v0.5.0 (2024-05-28)Req v0.5.0 brings testing enhancements, errors standardization, %Req.Response.Async{}, and more improvements and bug fixes.Testing EnhancementsIn previous releases, we could only create test stubs (using Req.Test.stub/2), that is, fake HTTP servers which had predefined behaviour. Let's say we're integrating with a third-party weather service and we might create a stub for it like below:Req.Test.stub(MyApp.Weather, fn conn -> Req.Test.json(conn, %{"celsius" => 25.0}) end)Anytime we hit this fake we'll get the same result. This works extremely well for simple integrations however it's not quite enough for more complicated ones. Imagine we're using something like AWS S3 and we test uploading some data and reading it back again. While we could do this:Req.Test.stub(MyApp.S3, fn conn when conn.method == "PUT" -> # ... conn when conn.method == "GET" -> # ... end)making the test just a little bit more thorough will make it MUCH more complicated, for example: the first GET request should return a 404, we then make a PUT, and now GET should return a 200. We could solve it by adding some state to our test (e.g. an agent) but there is a simpler way and that is to set request expectations using the new Req.Test.expect/3 function:Req.Test.expect(MyApp.S3, fn conn when conn.method == "GET" -> Plug.Conn.send_resp(conn, 404, "not found") end) Req.Test.expect(MyApp.S3, fn conn when conn.method == "PUT" -> {:ok, body, conn} = Plug.Conn.read_body(conn) assert body == "foo" Plug.Conn.send_resp(conn, 200, "") end) Req.Test.expect(MyApp.S3, fn conn when conn.method == "GET" -> Plug.Conn.send_resp(conn, 200, "foo") end)The important part is the request expectations are meant to run in order (and fail if they don't).In this release we're also adding Req.Test.transport_error/2, a way to simulate network errors.Here is another example using both of the new features, let's simulate a server that is having issues: on the first request it is not responding and on the following two requests it returns an HTTP 500. Only on the fourth request it returns an HTTP 200. Req by default automatically retries transient errors (using retry step) so it will make multiple requests exercising all of our request expectations:iex> Req.Test.expect(MyApp.S3, &Req.Test.transport_error(&1, :econnrefused)) iex> Req.Test.expect(MyApp.S3, 2, &Plug.Conn.send_resp(&1, 500, "internal server error")) iex> Req.Test.expect(MyApp.S3, &Plug.Conn.send_resp(&1, 200, "ok")) iex> Req.get!(plug: {Req.Test, MyApp.S3}).body # 15:57:06.309 [error] retry: got exception, will retry in 1000ms, 3 attempts left # 15:57:06.309 [error] ** (Req.TransportError) connection refused # 15:57:07.310 [error] retry: got response with status 500, will retry in 2000ms, 2 attempts left # 15:57:09.311 [error] retry: got response with status 500, will retry in 4000ms, 1 attempt left "ok"Finally, for parity with Mox, we add functions for setting ownership mode:Req.Test.set_req_test_from_context/1Req.Test.set_req_test_to_private/1Req.Test.set_req_test_to_shared/1And for verifying expectations:Req.Test.verify!/0Req.Test.verify!/1Req.Test.verify_on_exit!/1Thanks to Andrea Leopardi for driving the testing improvements.Standardized ErrorsIn previous releases, when using the default adapter, Finch, Req could return these exceptions on network/protocol errors: Mint.TransportError, Mint.HTTPError, and Finch.Error. They have now been standardized into: Req.TransportError and Req.HTTPError for more consistent experience. In fact, this standardization was the pre-requisite of adding Req.Test.transport_error/2!Two additional exception structs have been added: Req.ArchiveError and Req.DecompressError for zip/tar/etc errors in decode_body and gzip/br/zstd/etc errors in decompress_body respectively. Additionally, decode_body now returns Jason.DecodeError instead of raising it.%Req.Response.Async{}In previous releases we added ability to stream response body chunks into the current process mailbox using the into: :self option. When such is used, the response.body is now set to Req.Response.Async struct which implements the Enumerable protocol.Here's a quick example:resp = Req.get!("http://httpbin.org/stream/2", into: :self) resp.body #=> #Req.Response.Async<...> Enum.each(resp.body, &IO.puts/1) # {"url": "http://httpbin.org/stream/2", ..., "id": 0} # {"url": "http://httpbin.org/stream/2", ..., "id": 1}Here is another example where we use Req to talk to two different servers. The first server produces some test data, strings "foo", "bar" and "baz". The second one is an "echo" server, it simply responds with the request body it returned. We then stream data from one server, transform it, and stream it to the other one:Mix.install([ {:req, "~> 0.5"}, {:bandit, "~> 1.0"} ]) {:ok, _} = Bandit.start_link( scheme: :http, port: 4000, plug: fn conn, _ -> conn = Plug.Conn.send_chunked(conn, 200) {:ok, conn} = Plug.Conn.chunk(conn, "foo") {:ok, conn} = Plug.Conn.chunk(conn, "bar") {:ok, conn} = Plug.Conn.chunk(conn, "baz") conn end ) {:ok, _} = Bandit.start_link( scheme: :http, port: 4001, plug: fn conn, _ -> {:ok, body, conn} = Plug.Conn.read_body(conn) Plug.Conn.send_resp(conn, 200, body) end ) resp = Req.get!("http://localhost:4000", into: :self) stream = resp.body |> Stream.with_index() |> Stream.map(fn {data, idx} -> "[#{idx}]#{data}" end) Req.put!("http://localhost:4001", body: stream).body #=> "[0]foo[1]bar[2]baz"Req.Response.Async is an experimental feature which may change in the future.The existing caveats to into: :self still apply, that is:If the request is sent using HTTP/1, an extra process is spawned to consume messages from the underlying socket.On both HTTP/1 and HTTP/2 the messages are sent to the current process as soon as they arrive, as a firehose with no back-pressure.If you wish to maximize request rate or have more control over how messages are streamed, use into: fun or into: collectable instead.Full v0.5.0 CHANGELOGReq: Deprecate setting :headers to values other than string/integer/DateTime. This is to potentially allow special handling of atom values in the future.Req: Add Req.run/2 and Req.run!/2.Req: into: :self now sets response.body as Req.Response.Async which implements enumerable.Req.Request: Deprecate setting :redact_auth. It now has no effect. Instead of allowing to opt out of, we give an idea what the secret was without revealing it fully:iex> Req.new(auth: {:basic, "foobar:baz"}) %Req.Request{ options: %{auth: {:basic, "foo*******"}}, ... } iex> Req.new(headers: [authorization: "bearer foobarbaz"]) %Req.Request{ headers: %{"authorization" => ["bearer foo******"]}, ... }Req.Request: Deprecate halt/1 in favour of Req.Request.halt/2.Req.Test: Add Req.Test.transport_error/2 to simulate transport errors.Req.Test: Add Req.Test.expect/3.Req.Test: Add functions for setting ownership mode: Req.Test.set_req_test_from_context/1, Req.Test.set_req_test_to_private/1, Req.Test.set_req_test_to_shared/1 and for verifying expectations: Req.Test.verify!/0, Req.Test.verify!/1, and Req.Test.verify_on_exit!/1.Req.Test: Add Req.Test.html/2.Req.Test: Add Req.Test.text/2.Req.Test: Drop :nimble_ownership dependency.Req.Test: Deprecate Req.Test.stub/1, i.e. the intended use case is to only work with plug stubs/mocks.decode_body: Return Jason.DecodeError on JSON errors instead of raising it.decode_body: Return Req.ArchiveError on tar/zip errors.decompress_body: Return Req.DecompressError.put_aws_sigv4: Drop :aws_signature dependency.retry: (BREAKING CHANGE) Consider %Req.TransportError{reason: :closed | :econnrefused | :timeout} as transient. Previously any exceptions with those reason values were consider as such.retry: (BREAKING CHANGE) Consider %Req.HTTPError{protocol: :http2, reason: :unprocessed} as transient.run_finch: (BREAKING CHANGE) Return Req.HTTPError instead of Mint.HTTPError.run_finch: (BREAKING CHANGE) Return Req.TransportError instead of Mint.TransportError.run_finch: Set inet6: true if URL looks like IPv6 address.put_plug: Move most documentation to run_plug.run_plug: Make public.run_plug: Add support for simulating network issues using Req.Test.transport_error/2.run_plug: Support passing 2-arity functions as plugs.run_plug: Automatically fetch query params.verify_checksum: Fix handling compressed responses.v0.4.14 (2024-03-15)redirect: Return Req.TooManyRedirectsError exception.Previously we always raised a RuntimeError. Besides changing the exception struct, now it is returned:iex> Req.get("https://httpbin.org/redirect/4", max_redirects: 3) # 07:08:06.868 [debug] redirecting to /relative-redirect/3 # 07:08:06.988 [debug] redirecting to /relative-redirect/2 # 07:08:07.109 [debug] redirecting to /relative-redirect/1 {:error, %Req.TooManyRedirectsError{max_redirects: 3}}When users where using functions like Req.get!, the exception will of course still be raised.Relax nimble_ownership version requirementReq.Test: Allow plug stub to be a module or {module, options}Req.Test: Document stubbing with Broadwayv0.4.13 (2024-03-07)run_finch: Default to connect_options: [protocols: [:http1]] due to regression with HTTP/2 requests over HTTP/1 connections (protocols: [:http1, :http2]) with request body size exceeding 64kib.v0.4.12 (2024-03-06)Req: Add response body streaming via into: :self, Req.parse_message/2, and Req.cancel_async_response/1.Req: Deprecate Req.update/2 in favour of Req.merge/2Req.Test: Add Req.Test.allow/3compressed: Default compressed: false when streaming response bodyput_base_url: Allow :base_url to be a 0-arity function or MFArgsput_plug: Do not leak Plug.Test messagesv0.4.11 (2024-02-19)Req.Test.json/2: Don't crash compilation when Plug is not availablev0.4.10 (2024-02-19)run_finch: Default to connect_options: [protocols: [:http1, :http2]].run_finch: Change version requirement to ~> 0.17, that is all versions up to 1.0.put_aws_sigv4: Support streaming request body.auth: Always update authorization header.decode_body: Gracefully handle multiple content-type values.Req.Request.new/1: Use URI.parse for now.v0.4.9 (2024-02-14)retry: Raise on invalid return from :retry_delay functionrun_finch: Update to Finch 0.17run_finch: Deprecate connect_options: [protocol: ...] in favour of connect_options: [protocols: ...]] which defaults to [:http1, :http2], that is, make request using HTTP/1 but if negotiated switch to HTTP/2 over the HTTP/1 connection.New step: put_aws_sigv4 - signs request with AWS Signature Version 4.v0.4.8 (2023-12-11)put_plug: Fix response streaming. Previously we were relying on unreleased Plug features (which may never get released). Now, Plug adapter will emit the entire response body as one chunk. Thus, plug: plug, into: fn ... -> {:halt, acc} end is not yet supported as it requires Plug changes that are still being discussed. On the flip side, we should have much more stable Plug integration regardless of this small limitation.v0.4.7 (2023-12-11)put_plug: Don't crash if plug is not installed and :plug is not usedv0.4.6 (2023-12-11)New step: checksumput_plug: Fix response streaming when plug uses send_resp or send_fileretry: Retry on :closedv0.4.5 (2023-10-27)decompress_body: Remove content-length headerauth: Deprecate auth: {user, pass} in favour of auth: {:basic, "user:pass"}Req.Request: Allow steps to be {mod, fun, args}v0.4.4 (2023-10-05)compressed: Check for optional depenedencies brotli and ezstd only at compile-time. (backported from v0.3.12.)decode_body: Check for optional depenedency nimble_csv at compile-time. (backported from v0.3.12.)run_finch: Add :finch_private optionv0.4.3 (2023-09-13)Req.new/1: Fix setting :redact_authReq.Request: Add Req.Request.get_option_lazy/3Req.Request: Add Req.Request.drop_options/2v0.4.2 (2023-09-04)put_plug: Handle response streaming on Plug 1.15+.Don't warn on mixed-case header namesv0.4.1 (2023-09-01)Fix Req.Request Inspect regressionv0.4.0 (2023-09-01)Req v0.4.0 changes headers to be maps, adds request & response streaming, and improves steps.Change Headers to be MapsPreviously headers were lists of name/value tuples, e.g.:[{"content-type", "text/html"}]This is a standard across the ecosystem (with minor difference that some Erlang libraries use charlists instead of binaries.)There are some problems with this particular choice though:We cannot use headers[name]We cannot use pattern matchingIn short, this representation isn't very ergonomic to use.Now headers are maps of string names and lists of values, e.g.:%{"content-type" => ["text/html"]}This allows headers[name] usage:response.headers["content-type"] #=> ["text/html"]and pattern matching:case Req.request!(req) do %{headers: %{"content-type" => ["application/json" <> _]}} -> # handle JSON response endThis is a major breaking change. If you cannot easily update your app or your dependencies, do:# config/config.exs config :req, legacy_headers_as_lists: trueThis legacy fallback will be removed on Req 1.0.There are two other changes to headers in this release.Header names are now case-insensitive in functions like Req.Response.get_header/2.Trailer headers, or more precisely trailer fields or simply trailers, are now stored in a separate trailers field on the %Req.Response{} struct as long as you use Finch 0.17+.Add Request Body StreamingReq v0.4 adds official support for request body streaming by setting the request body to an enumerable. Here's an example:iex> stream = Stream.duplicate("foo", 3) iex> Req.post!("https://httpbin.org/post", body: stream).body["data"] "foofoofoo"The enumerable is passed through request steps and they may change it. For example, the compress_body step gzips the request body on the fly.Add Response Body StreamingReq v0.4 also adds response body streaming, via the :into option.Here's an example where we download the first 20kb (by making a range request, via the put_range step) of Elixir release zip. We stream the response body into a function and can handle each body chunk. The function receives a {:data, data}, {req, resp} and returns a {:cont | :halt, {req, resp}} tuple.resp = Req.get!( url: "https://github.com/elixir-lang/elixir/releases/download/v1.15.4/elixir-otp-26.zip", range: 0..20_000, into: fn {:data, data}, {req, resp} -> IO.inspect(byte_size(data), label: :chunk) {:cont, {req, resp}} end ) # output: 17:07:38.131 [debug] redirecting to https://objects.githubusercontent.com/github-production-release-asset-2e6(...) # output: chunk: 16384 # output: chunk: 3617 resp.status #=> 206 resp.headers["content-range"] #=> ["bytes 0-20000/6801977"] resp.body #=> ""Notice we only stream response body, that is, Req automatically handles HTTP response status and headers. Once the stream is done, Req passes the response through response steps which allows following redirects, retrying on errors, etc. Response body is set to empty string "" which is then ignored by decompress_body, decode_body, and similar steps. If you need to decompress or decode incoming chunks, you need to do that in your custom into: fun function.As the name :into implies, we can also stream response body into any Collectable. Here's a similar snippet to above where we stream to a file:resp = Req.get!( url: "https://github.com/elixir-lang/elixir/releases/download/v1.15.4/elixir-otp-26.zip", range: 0..20_000, into: File.stream!("elixit-otp-26.zip.1") ) # output: 17:07:38.131 [debug] redirecting to (...) resp.status #=> 206 resp.headers["content-range"] #=> ["bytes 0-20000/6801977"] resp.body #=> %File.Stream{}Full CHANGELOGChange request.headers and response.headers to be maps.Ensure request.headers and response.headers are downcased.Per RFC 9110: HTTP Semantics, HTTP headers should be case-insensitive. However, per RFC 9113: HTTP/2 headers must be sent downcased.Req headers are now stored internally downcased and all accessor functions like Req.Response.get_header/2 are downcasing the given header name.Add trailers field to Req.Response struct. Trailer field is only filled in on Finch 0.17+.Make request.registered_options internal representation private.Make request.options internal representation private.Currently request.options field is a map but it may change in the future. One possible future change is using keywords lists internally which would allow, for example, Req.new(params: [a: 1]) |> Req.merge(params: [b: 2]) to keep duplicate :params in request.options which would then allow to decide the duplicate key semantics on a per-step basis. And so, for example, put_params would merge params but most steps would simply use the first value.To have some room for manoeuvre in the future we should stop pattern matching on request.options. Calling request.options[key], put_in(request.options[key], value), and update_in(request.options[key], fun) is allowed.Fix typespecs for some functionsDeprecate output step in favour of into: File.stream!(path).Rename follow_redirects step to redirectredirect: Rename :follow_redirects option to :redirect.redirect: Rename :location_trusted option to :redirect_trusted.redirect: Change HTTP request method to GET only on POST requests that result in 301..303.Previously we were changing the method to GET for all 3xx except 307 and 308.decompress_body: Remove support for deflate compression (which was broken)decompress_body: Don't crash on unknown codecdecompress_body: Fix handling HEAD requestsdecompress_body: Re-calculate content-length header after decompresiondecompress_body: Remove content-encoding header after decompressiondecode_body: Do not decode response with content-encoding headerrun_finch: Add :inet6 optionretry: Support retry: :safe_transient which retries HTTP 408/429/500/502/503/504 or exceptions with reason field set to :timeout/:econnrefused.:safe_transient is the new default retry mode. (Previously we retried on 408/429/5xx and any exception.)retry: Support retry: :transient which is the same as :safe_transient except it retries on all HTTP methodsretry: Use retry-after header value on HTTP 503 Service Unavailable. Previously only HTTP 429 Too Many Requests was using this header value.retry: Support retry: &fun/2. The function receives request, response_or_exception and returns either:true - retry with the default delay{:delay, milliseconds} - retry with the given delayfalse/nil - don't retryretry: Deprecate retry: :safe in favour of retry: :safe_transientretry: Deprecate retry: :never in favour of retry: falseReq.request/2: Improve error message on invalid argumentsReq.merge/2: Do not duplicate headersReq.merge/2: Merge :paramsReq.Request: Fix displaying redacted basic authenticationReq.Request: Add Req.Request.get_option/3Req.Request: Add Req.Request.fetch_option/2Req.Request: Add Req.Request.fetch_option!/2Req.Request: Add Req.Request.delete_option/2Req.Response: Add Req.Response.delete_header/2Req.Response: Add Req.Response.update_private/4v0.3.12 (2023-08-05)compressed: Check for optional depenedencies brotli and ezstd only at compile-time.decode_body: Check for optional depenedency nimble_csv at compile-time.v0.3.11 (2023-07-24)Support Req.get(options), Req.post(options), etcAdd Req.Request.new/1retry: Fix returning correct private.req_retry_countv0.3.10 (2023-06-20)decompress_body: No-op on non-binary response bodydecompress_body: Support multiple content-encoding headersdecode_body: Remove :extract optionRemove deprecated Req.post!(url, body) and similar functionsv0.3.9 (2023-06-08)put_path_params: URI-encode path paramsv0.3.8 (2023-05-22)Add :redact_auth option to redact auth credentials, defaults to true.Soft-deprecate Req.Request.run,run! in favour of Req.Request.run_request/1.v0.3.7 (2023-05-18)Deprecate setting headers to %NaiveDateTime{}, always use %DateTime{}.decode_body: Add :decode_json option[follow_redirects]: Add :redirect_log_level[follow_redirects]: Preserve HTTP method on 307/308 redirectsrun_finch: Allow :finch_request to perform the underlying request. This deprecates passing 1-arity function f(finch_request) in favour of 4-arity f(request, finch_request, finch_name, finch_options).v0.3.6 (2023-03-06)run_finch: Fix setting :hostname optiondecode_body: Add :extract option to automatically extract archives (zip, tar, etc)v0.3.5 (2023-02-01)New step: put_path_paramsauth: Accept stringv0.3.4 (2023-01-03)retry: Add :retry_log_level optionv0.3.3 (2022-12-08)[follow_redirects]: Inherit scheme from previous locationrun_finch: Fix setting connect timeoutrun_finch: Add :finch_request optionv0.3.2 (2022-11-14)decode_body: Decode JSON when response is json-api mime typeput_params: Fix bug when params have been duplicated when retrying requesetretry: Remove retry: :always optionretry: Soft-deprecate retry: :never in favour of retry: falserun_finch: Add :transport_opts, :proxy_headers, :proxy, and :client_settings optionsReq.Response.json/2: Do not override content-typev0.3.1 (2022-09-09)encode_body: Set Accept header in JSON requestsput_base_url: Fix merging with leading and/or trailing slashesFix merging :adapter optionAdd get/2, post/2, put/2, patch/2, delete/2 and head/2v0.3.0 (2022-06-21)Req v0.3.0 brings redesigned API, new steps, and improvements to existing steps.New APIThe new API allows building a request struct with all the built-in steps. It can be then piped to functions like Req.get!/2:iex> req = Req.new(base_url: "https://api.github.com") iex> req |> Req.get!(url: "/repos/sneako/finch") |> then(& &1.body["description"]) "Elixir HTTP client, focused on performance" iex> req |> Req.get(url: "/repos/elixir-mint/mint") |> then(& &1.body["description"]) "Functional HTTP client for Elixir with support for HTTP/1 and HTTP/2."Setting body and encoding it to form/JSON is now done through :body/:form/:json options:iex> Req.post!("https://httpbin.org/anything", body: "hello!").body["data"] "hello!" iex> req = Req.new(url: "https://httpbin.org/anything") iex> Req.post!(req, form: [x: 1]).body["form"] %{"x" => "1"} iex> Req.post!(req, json: %{x: 2}).body["form"] %{"x" => 2}Improved Error HandlingReq now validates option names ensuring users didn't accidentally mistyped them. If they did, it will try to give a helpful error message. Here are some examples:Req.request!(urll: "https://httpbin.org") ** (ArgumentError) unknown option :urll. Did you mean :url? Req.new(bas_url: "https://httpbin.org") ** (ArgumentError) unknown option :bas_url. Did you mean :base_url?Req also has a new option to handle HTTP errors (4xx/5xx). By default it will continue to return the error responses:Req.get!("https://httpbin.org/status/404") #=> %Req.Response{status: 404, ...}but users can now pass http_errors: :raise to raise an exception instead:Req.get!("https://httpbin.org/status/404", http_errors: :raise) ** (RuntimeError) The requested URL returned error: 404 Response body: ""This is especially useful in one-off scripts where we only really care about the "happy path" but would still like to get a good error message when something unexpected happened.PluginsFrom the very beginning, Req could be extended with custom steps. To make using such custom steps by others even easier, they can be packaged up into plugins.Here are some examples:req_easyhtmlreq_s3req_hexreq_github_oauthAnd here's how they can be used:Mix.install([ {:req, "~> 0.3.0"}, {:req_easyhtml, github: "wojtekmach/req_easyhtml"}, {:req_s3, github: "wojtekmach/req_s3"}, {:req_hex, github: "wojtekmach/req_hex"}, {:req_github_oauth, github: "wojtekmach/req_github_oauth"} ]) req = (Req.new(http_errors: :raise) |> ReqEasyHTML.attach() |> ReqS3.attach() |> ReqHex.attach() |> ReqGitHubOAuth.attach()) Req.get!(req, url: "https://elixir-lang.org").body[".entry-summary h5"] #=> # #EasyHTML[<h5> # Elixir is a dynamic, functional language for building scalable and maintainable applications. # </h5>] Req.get!(req, url: "s3://ossci-datasets").body #=> # [ # "mnist/", # "mnist/t10k-images-idx3-ubyte.gz", # "mnist/t10k-labels-idx1-ubyte.gz", # "mnist/train-images-idx3-ubyte.gz", # "mnist/train-labels-idx1-ubyte.gz" # ] Req.get!(req, url: "https://repo.hex.pm/tarballs/req-0.1.0.tar").body["metadata.config"]["links"] #=> %{"GitHub" => "https://github.com/wojtekmach/req"} Req.get!(req, url: "https://api.github.com/user").body["login"] # Outputs: # paste this user code: # # 6C44-30A8 # # at: # # https://github.com/login/device # # open browser window? [Yn] # 15:22:28.350 [info] response: authorization_pending # 15:22:33.519 [info] response: authorization_pending # 15:22:38.678 [info] response: authorization_pending #=> "wojtekmach" Req.get!(req, url: "https://api.github.com/user").body["login"] #=> "wojtekmach"Notice all plugins can be attached to the same request struct which makes it really easy to explore different endpoints.See "Writing Plugins" section in Req.Request module documentation for more information.Plug IntegrationReq can now be used to easily test plugs using the :plug option:defmodule Echo do def call(conn, _) do "/" <> path = conn.request_path Plug.Conn.send_resp(conn, 200, path) end end test "echo" do assert Req.get!("http:///hello", plug: Echo).body == "hello" endyou can define plugs as functions too:test "echo" do echo = fn conn -> "/" <> path = conn.request_path Plug.Conn.send_resp(conn, 200, path) end assert Req.get!("http:///hello", plug: echo).body == "hello" endwhich is particularly useful to create HTTP service mocks with tools like Bypass.Request AdaptersWhile Req always used Finch as the underlying HTTP client, it was designed from the day one to easily swap it out. This is now even easier with an :adapter option.Here is a mock adapter that always returns a successful response:adapter = fn request -> response = %Req.Response{status: 200, body: "it works!"} {request, response} end Req.request!(url: "http://example", adapter: adapter).body #=> "it works!"Here is another one that uses the json/2 function to conveniently return a JSON response:adapter = fn request -> response = Req.Response.json(%{hello: 42}) {request, response} end resp = Req.request!(url: "http://example", adapter: adapter) resp.headers #=> [{"content-type", "application/json"}] resp.body #=> %{"hello" => 42}And here is a naive Hackney-based adapter and how we can use it:hackney = fn request -> case :hackney.request( request.method, URI.to_string(request.url), request.headers, request.body, [:with_body] ) do {:ok, status, headers, body} -> headers = for {name, value} <- headers, do: {String.downcase(name), value} response = %Req.Response{status: status, headers: headers, body: body} {request, response} {:error, reason} -> {request, RuntimeError.exception(inspect(reason))} end end Req.get!("https://api.github.com/repos/elixir-lang/elixir", adapter: hackney).body["description"] #=> "Elixir is a dynamic, functional language designed for building scalable and maintainable applications"See "Adapter" section in Req.Request module documentation for more information.Major changesAdd high-level functional API: Req.new(...) |> Req.request(...), Req.new(...) |> Req.get!(...), etc.Add Req.Request.options field that steps can read from. Also, make all steps be arity 1.When using "High-level" API, we now run all steps by default. (The steps, by looking at request.options, can decide to be no-op.)Move low-level API to Req.RequestMove built-in steps to Req.StepsAdd step namesAdd Req.head!/2Add Req.patch!/2Add Req.Request.adapter fieldAdd Req.Request.merge_options/2Add Req.Request.register_options/2Add Req.Request.put_header/3Add Req.Request.put_headers/2Add Req.Request.put_new_header/3Add Req.Request.get_header/2Add Req.Request.update_private/4Add Req.Response.new/1Add Req.Response.json/2Add Req.Response.get_header/2Add Req.Response.put_header/3Rename put_if_modified_since step to cacheRename decompress step to decompress_bodyRemove put_default_steps stepRemove run_steps stepRemove put_default_headers stepRemove encode_headers step. The headers are now encoded in Req.new/1 and Req.request/2Remove Req.Request.unix_socket field. Add option on run_finch step with the same name instead.Require Elixir 1.12Step changesNew step: put_plugNew step: put_user_agent (replaces part of removed put_default_headers)New step: compressed (replaces part of removed put_default_headers)New step: compress_bodyNew step: [output]New step: handle_http_errorsput_base_url: Ignore base URL if given URL contains schemerun_finch: Add :connect_options which dynamically starts (or re-uses already started) Finch pool with the given connection options.run_finch: Replace :finch_options with :receive_timeout and :pool_timeout optionsencode_body: Add :form and :json options (previously used as {:form, data} and {:json, data})cache: Include request method in cache keydecompress_body, compressed: Support Brotlidecompress_body, compressed: Support Zstandarddecode_body: Support decode_body: false option to disable automatic body decoding[follow_redirects]: Change method to GET on 301..303 redirects[follow_redirects]: Don't send auth headers on redirect to different scheme/host/port unless location_trusted: true is setretry: The Retry-After response header on HTTP 429 responses is now respectedretry: The :retry option can now be set to :safe (default) to only retry GET/HEAD requests on HTTP 408/429/5xx responses or exceptions, :always to always retry, :never to never retry, and fun - a 1-arity function that accepts either a Req.Response or an exception struct and returns boolean whether to retryretry: The :retry_delay option now accepts a function that takes a retry count (starting at 0) and returns the delay. Defaults to a simple exponential backoff: 1s, 2s, 4s, 8s, ...DeprecationsDeprecate calling Req.post!(url, body) in favour of Req.post!(url, body: body). Also, deprecate Req.post!(url, {:form, data}) in favour of Req.post!(url, form: data). and Req.post!(url, {:json, data}) in favour of Req.post!(url, json: data). Same for Req.put!/2.Deprecate setting retry: [delay: delay, max_retries: max_retries] in favour of retry_delay: delay, max_retries: max_retries.Deprecate setting cache: [dir: dir] in favour of cache_dir: dir.Deprecate Req.build/3 in favour of manually building the struct.v0.2.2 (2022-04-04)Relax Finch version requirementv0.2.1 (2021-11-24)Add :private field to ResponseUpdate Finch to 0.9.1v0.2.0 (2021-11-08)Rename normalize_headers to encode_headersRename prepend_default_steps to put_default_stepsRename encode and decode to encode_body and decode_bodyRename netrc to load_netrcRename finch step to run_finchRename if_modified_since to put_if_modified_sinceRename range to put_rangeRename params to put_paramsRename request.uri to request.urlChange response/error step contract from f(req, resp_err) to f({req, resp_err})Support mime 2.xAdd Req.Response structAdd put!/3 and delete!/2Add run_steps/2Initial support for UNIX domain socketsAccept {module, args} and module as stepsEnsure get_private and put_private have atom keysput_default_steps: Use MFArgs instead of captures for the default stepsput_if_modified_since: Fix generating internet timeencode_headers: Encode header valuesretry: Rename :max_attempts to :max_retriesv0.1.1 (2021-07-16)Fix append_request_steps/2 and prepend_request_steps/2 (they did the opposite)Add finch/1v0.1.0 (2021-07-15)Initial release

```
Req.Response
```

**Pattern 6:** making the test just a little bit more thorough will make it MUCH more complicated, for example: the first GET request should return a 404, we then make a PUT, and now GET should return a 200. We could solve it by adding some state to our test (e.g. an agent) but there is a simpler way and that is to set request expectations using the new Req.Test.expect/3 function:

```
Req.Test.expect/3
```

**Pattern 7:** Here's a quick example:

```
resp = Req.get!("http://httpbin.org/stream/2", into: :self)
resp.body
#=> #Req.Response.Async<...>
Enum.each(resp.body, &IO.puts/1)
# {"url": "http://httpbin.org/stream/2", ..., "id": 0}
# {"url": "http://httpbin.org/stream/2", ..., "id": 1}
```

**Pattern 8:** This allows headers[name] usage:

```
headers[name]
```

### Example Code Patterns

**Example 1** (javascript):
```javascript
Mix.install([
  {:req, "~> 0.5.0"}
])

Req.get!("https://api.github.com/repos/wojtekmach/req").body["description"]
#=> "Req is a batteries-included HTTP client for Elixir."
```

**Example 2** (javascript):
```javascript
Mix.install([
  {:req, "~> 0.5.0"}
])

Req.get!("https://api.github.com/repos/wojtekmach/req").body["description"]
#=> "Req is a batteries-included HTTP client for Elixir."
```

**Example 3** (javascript):
```javascript
plug = fn conn ->
  {:ok, body, conn} = Plug.Conn.read_body(conn)
  assert JSON.decode!(body) == %{"x" => 1}
  Plug.Conn.send_resp(conn, 200, "ok")
end

Req.put!(plug: plug, json: %{x: 1})
```

**Example 4** (javascript):
```javascript
plug = fn conn ->
  assert conn.body_params == %{"x" => 1}
  Plug.Conn.send_resp(conn, 200, "ok")
end

Req.put!(plug: plug, json: %{x: 1})
```

## Reference Files

This skill includes comprehensive documentation in `references/`:

- **api.md** - Api documentation
- **getting_started.md** - Getting Started documentation
- **testing.md** - Testing documentation

Use `view` to read specific reference files when detailed information is needed.

## Working with This Skill

### For Beginners
Start with the getting_started or tutorials reference files for foundational concepts.

### For Specific Features
Use the appropriate category reference file (api, guides, etc.) for detailed information.

### For Code Examples
The quick reference section above contains common patterns extracted from the official docs.

## Resources

### references/
Organized documentation extracted from official sources. These files contain:
- Detailed explanations
- Code examples with language annotations
- Links to original documentation
- Table of contents for quick navigation

### scripts/
Add helper scripts here for common automation tasks.

### assets/
Add templates, boilerplate, or example projects here.

## Notes

- This skill was automatically generated from official documentation
- Reference files preserve the structure and examples from source docs
- Code examples include language detection for better syntax highlighting
- Quick reference patterns are extracted from common usage examples in the docs

## Updating

To refresh this skill with updated documentation:
1. Re-run the scraper with the same configuration
2. The skill will be rebuilt with the latest information
